一、分布式锁概述
    分布式锁在一组进程之间提供课一种互斥机制。在任何时刻，在任何时刻只有一个进程可以持有锁。分布式锁可以在大型分布式系统中实现领导者选举，在任何时间点，尺有所的那个进程就是系统的领导者。
    1、为了使用 Zookeeper 来实现分布式锁服务，须使用顺序 znode 来为那些竞争锁的进程强制排序。
       1.1、思路：
            1)、首先执行一个作为锁的 znode,通常用它来描述被锁定的实体，称为 /leader；
      	    2)、然后希望获得锁的客户端创建一些短暂的顺序 znode， 作为锁 znode 的子节点；
      	    3)、在任何时间点，顺序号最小的客户端将持有锁；
      	    4)、通过删除 znode 的子节点即可简单的将锁释放；
      	    5)、另外，如果客户端进行死亡，对应的短暂 znode 也会被删除；
      	    6)、接下来，创建顺序号紧跟前一个的 znode 将持有锁；
      	    7)、通过创建一个关于 znode 的删除的观察，可以是客户端在获得锁时得到通知。
    2、问题与方案
        2.1、羊群效应
            1)、问题
                考虑有 N 多客户端的情况，所有客户端都在请求获得锁，每一个客户端都会在锁 znode 上设置一个反差，用于捕捉子节点的变化。
                每次锁被释放或者另外一个进程来时申请获取所的时候，观察都会被触发，并且每个客户端都会收到一个通知。
                “羊群效应”就是指大量客户端收到同一事件的通知，但实际上只有很少一部分需要处理这一事件。在这种情况下，
                只有一个客户端会成功的获取锁，但是维护过程及所有客户端发送观察事件会产生峰值流量，这回对 Zookeeper 服务器造成压力。
            2)、解决方案
                为了避免出现这种现象，我们可以优化通知的条件。关键在于只有在前一个顺序号的子节点消失时才需要通知下一个客户端，而不是删除（或创建）
                任何子节点时都需要通知。
        2.2、可恢复的异常
            1)、问题
                这种申请锁的算法还存在一个问题，就是不能处理因连接丢失而导致的 create 操作失败。如前所述，在这种情况下，我们不知道操作是成功还是失败。
                由于创建一个顺序 znode 是非幂等操作，所以我们不能简单的重试，以为如果第一次已经创建成功，重试会使我们多出一个永远删不掉的 znode(至少在会话结束前)。
                可能在成结果就是会出现死锁。
            2)、解决方案
                这个问题的关键点在于连接断开重连之后客户端不能够判断它是否已经创建过子节点。
                所以解决方案是在 znode 的名称中嵌入一个 ID，如果客客户端出现连接丢失的情况，重新连接之前它便可以对锁节点的所有子节点进行检查，
                检查是否有子节点的名称中包含其 ID。如果有，客户端就知道创建操作已经成功；如果没有，则客户端可以安全创建一个新的顺序子节点。
            3)、相关
                  客户端会话的 ID 是一个长整数，并且在 Zookeeper 服务中是唯一的，因此非常适合在连接丢失后用于识别客户端。可以通过调用 Java Zookeeper 类
                  的 getSessionId() 方法来获得会话的 ID。

                  在创建短暂顺序 znode 时应当采用 lock-<sessionId>-顺序号 这样的命名方式。Zookeeper 在其尾部添加顺序号之后，znode 的名称会形如
                  lock-<sessionId>-<sequenceNumber>。由于顺序号对于父节点来说是唯一的，但对于子节点并不唯一，因此次用这样的命名方式可以让子节点在保持创建顺序的
                  同时能够确定自己的创建者。
        2.3、不可恢复的异常
            1)、问题
                如果一个客户端的 Zookeeper 会话过期，那么它所创建的短暂 znode 将会被删除，已持有的锁会被释放，或是放弃了申请锁的位置，使用锁的应用程序
                应当意识到它已经不再持有锁，应当清理它的状态，然后通过创建并尝试申请一个新的锁对象来重新启动。这个过程是有应用程序控制的，而不是锁，因为锁
                是不能预知应用程序需要如何清理自己的状态。

二、Zookeeper 实现共享锁
        实现正确地实现一个分布式锁是一件棘手的事，因为很难对所有类型的故障都进行正确的解释处理。
        ZooKeeper带有一个 JavaWriteLock，客户端可以很方便地使用它。更多分布式数据结构和协议例如“屏障”(bafrier)、队列和两阶段提交协议。
        有趣的是它们都是同步协议，即使我们使用异步ZooKeeper基本操作（如通知）来实现它们。
        使用ZooKeeper可以实现很多不同的分布式数据结构和协议，
        ZooKeeper网站(http://hadoop.apache.org/zookeeper/)提供了一些用于实现分布式数据结构和协议的伪代码。
        ZooKeeper本身也带有一些棕准方法的实现，放在安装位置下的recipes目录中。

    1、利用节点名称的唯一性来实现共享锁
            Zookeeper 表面上的节点结构是一个和 unix 文件系统类似的小型的树状的目录结构，Zookeeper 机制规定：同一个目录下只能有一个唯一的文件名。
         思路
            利用名称的唯一性，加锁操作时，只需要所有客户端一起创建 /leader/lock 节点，只有一个创建成功，成功者获得锁。解锁时，只需要删除锁节点，
            其余的客户端再次进入竞争创建节点，直到所有客户端都获得锁。
            基于以上机制,可得流程图如下：
    2、利用顺序节点实现共享锁
            Zookeeper 中有一中节点叫做顺序节点。
            eg：我们在 /lock/ 节点下创建3个顺序子节点，Zookeeper 集群会按照提起创建的顺序来创建节点，
            节点分别为：/lock/000000001、/lock/000000002、/lock/000000003
            Zookeeper 中还有一种名为临时节点的节点，临时节点事由某一个客户端创建，当客户端与 Zookeeper 集群断开连接，则该临时节点会被删除。
        思路
            对于加锁的操作，可以让所有客户端都去 /lock 节点下创建临时、顺序节点，如果创建的客户端发现自身创建的节点序列号是 /lock/ 节点下最小的节点，
            则该客户端获得锁。否则，监视比自己创建节点的序列号小的节点(当前序列号在自己前面一个的节点)，进入等待。需要释放锁的时候，只需要将自身创建的
            节点删除即可。具体流程如下：



